### 练习项目

- [lab-我的微信好友](https://github.com/udacity/AIPND-cn-trial/blob/master/MyWechatFriends.ipynb)

- [lab-我的健康数据](https://github.com/udacity/MyHealthData-cn) 

### 项目反馈反馈

 [项目地址：P1_Robot_Controller](https://github.com/udacity/AIPND_P1_Robot_Controller) 

### 分析模拟环境的数据

任务1: 正确获取模拟环境的长和宽与模拟环境中第3行第6列元素

很棒！用`len()`函数可以获得`list`元素的个数，通过用索引来访问`list`中每一个位置的元素，牢记索引是从`0`开始的哦～

任务2: 正确计算模拟环境中，第一行和第三列的障碍物个数。

- 做得不错！这里也可以用zip+count来实现：

```
number_of_barriers_row1 = env_data[0].count(2)
number_of_barriers_col3 = list(zip(*env_data))[2].count(2)
```

任务3: 正确创建并赋值loc_map字典。

很棒！通过定义函数使得代码具有复用性，而不是将`Start`和`Destination`直接赋值坐标，很棒的做法！

### 控制机器人行动

任务4: 正确实现`is_move_valid_special`的函数

做得很棒！也可以参考以下的实现方法，看看是否会给你一些启发 :P：

```
def is_move_valid_special(loc, act):

    x, y = loc 
    if act == 'u':
        x -= 1
    elif act == 'd':
        x += 1
    elif act == 'l':
        y -= 1
    elif act == 'r':
        y += 1

    return (0 <= y <= columns - 1) and (0 <= x <= rows - 1) and (env_data[x][y] != 2)
```

任务5: 正确实现`is_move_valid`函数

👍

任务6: 学生正确回答`env_data`这个变量在任务4和任务5中的不同。

这里回答得不正确，请参考以下note：

1. 它们的区别在于前者是全局变量，后者是局部变量。
   Python 同多数编程语言一样，也有全局变量与局部变量的概念，两者的本质区别就是在于作用域。
   简单来说，全局变量是在全局范围内都可以访问，如果要修改它需要加上`global`字段，而局部变量是在某个函数中声明的，只能在该函数中调用它。
2. Python的每个对象都分为可变和不可变，主要的核心类型中，数字、字符串、元组是不可变的，列表、字典是可变的。可变参数作为参数是传引用到函数，所以在函数中对形参的修改会改变实参的值，[详见](https://www.cnblogs.com/blackmatrix/p/5614086.html)。

任务7: 正确编写一个名为 `valid_actions` 的函数。

做的不错！

任务8: 正确编写`move_robot`函数。

- 赞！试试看使用dict来实现这个功能：

```
def move_robot(loc, act):

    move_dict = {
        'u': (-1,0),
        'd': (1,0),
        'l': (0,-1),
        'r': (0,1)
    }

    return loc[0] + move_dict[act][0], loc[1] + move_dict[act][1]
```

任务9: 正确编写`random_choose_actions`函数。

做的不错！

### （可选）控制机器人走到终点

（可选）任务10: 尝试实现一个算法，能够对给定的模拟环境，输出机器人的行动策略，使之能够走到终点。

希望你能认真思考下这个问题～
首先，你需要学习下深度优先算法、广度优先算法、Dijkstra算法，而且这些算法都能解决这个问题。
而A*算法的出现时因为

- 深度/广度优先算法找到的路径可能不是最优解，但是运行时间短；
- 而Dijkstra算法能够保证找到最短路径，但是运行时间慢；

那怎样才能在保证效果的情况话，让运行时间也短呢？

所以A*算法其实是结合了广度优先算法和Dijkstra算法，关键就是下面这个等式：

```
f(n) = g(n) + h(n)
g(n) = 从起点 A 移动到指定方格的移动代价。
h(n) = 从指定的方格移动到终点 B 的估算成本。
```

- 一种极端情况，如果h(n)是0，则只有g(n)起作用，此时A*演变成Dijkstra算法，这保证能找到最短路径。
- 另一种极端情况，如果h(n)比g(n)大很多，则只有h(n)起作用，A*演变成BFS算法。

所以出于运行时间和运行效果的考虑，你可以权衡g(n)和h(n)，修改任意一个，从而得到一条好路径而不是一条完美的路径。
A*算法的流程其实是比较简单的，现在我们把所有步骤放在一起：

- 把起点加入 open list 。
- 重复如下过程：
  - 遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。
  - 把这个节点移到 close list 。
- 操作当前方格的 8 个相邻方格的每一个方格：
  - 如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。
  - 如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。
  - 如果它已经在 open list 中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更好，用 G 值作参考。更小的 G 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。如果你的 open list 是按 F 值排序的话，改变后你可能需要重新排序。
- 停止，如果满足条件：
  - 把终点加入到了 open list 中，此时路径已经找到了，或者
  - 查找终点失败，并且 open list 是空的，此时没有路径。
- 保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。

### 代码功能性

代码利用函数来避免重复代码。代码包含清晰的注释和变量名称，可读性较高。

代码的注释中并没有包含对于统计数字和可视化的推理说明。

## 【补充知识】

- 一个好的变量命名规则，能够让你的代码可读性更好。
- 在 Python 中，已经形成了一套比较公认的变量命名的方法，即 [PEP8规则](https://www.python.org/dev/peps/pep-0008/#prescriptive-naming-conventions) 。尽管里面有不少情况你可能还没接触到，但是希望你能够尽早形成一些变量命名的习惯，这样对你以后的代码可读性、排除 Bug 等方面都大有裨益。